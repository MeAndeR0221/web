# __`TCP（Transmission Control Protocol）`__
传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的端到端传输层通信协议，由IETF的RFC 793定义。
TCP旨在适应支持多网络应用的分层协议层次结构。互联网络与单个网络有很大的不同，因为互联网络的不同部分可能有截然不同的拓扑结构、带宽、延迟、数据包大小和其他参数。TCP的设计目标是能够动态地适应互联网络的这些特性，而且具备面对各种故障时的健壮性。
开放系统互联（Open System Interconnection）：
![[Pasted image 20220827225111.png]]
TCP工作在网络OSI的七层模型中的第四层——传输层，IP在第三层——网络层，ARP 在第二层——数据链路层；同时，我们需要简单的知道，数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端。这个基本的流程你需要知道，就是每个数据都会经过数据的封装和解封装的过程。
![[Pasted image 20220827230424.png]]
tcp协议比较复杂，因为它要实现可靠传输，为了确保它的可靠传输，于是协议就相当复杂了。它的主要特点是：
-   面向连接，就像打电话一样，必须一对一的接通电话，两个人才能讲电话，而udp有点像发微信，不需要对方做准备，我想发就发
-   点对点，每一条tcp连接只能是点对点，一对一
-   提供可靠交付，通过tcp传送的数据，无差错，不丢失，不重复，并且按序到达
-   全双工通信，即tcp双方都有缓存，发送方将数据传送给tcp缓存之后就可以做自己的事了，接收方在适当的时候读取缓存
-   面向字节流

可靠传输原理：
ip层只提供尽最大努力服务，也就是说，tcp层之下的网络所提供的是不可靠的传输，那么，tcp要采用什么措施才能实现可靠传输呢？
理想的传输条件有两个特点：
-   传输信道不产生差错；
-   不管发送方以多快的速率发送数据，接收方也来得及处理。
但实际上不可能的，网络总是变化的，有好有快，而且根据木桶理论，只要有一环较差，网络就好不起来。另外，接收主机的性能也有好有坏，数据处理自然也会有快有慢了。
如果网络不好，我没有收到传输的数据，可以让发送方重新发送数据。如果我处理数据的速度有限，可以告诉发送方速度不要过快，在某个速度之下。这就是tcp可靠传输的基本思想。

停止等待协议：
停止等待，就是每发送完一个分组就停止发送，等待对方确认，收到确认后再发送下一个分组。如果按照这个策略，那么传输肯定是可靠的，因为每个数据对方都会确认是否收到。
在无差错的情况下，情况如图所示：
![](https://pic3.zhimg.com/80/v2-0d3c6390ff115840f641c7949e2022f2_720w.jpg)
发送方发送一帧后，就会启用超时计数器，在计数时间范围内，如果还没有收到接收方发送过来的确认，那么就认为数据已丢失，就需要重新发送一次
![](https://pic1.zhimg.com/80/v2-c07b77f9af4fe9f5042198432a996a8c_720w.jpg)
这样做，肯定是可靠传输的，但有个问题，信道复用率太低，发送方发送完之后就处于等待之中了，整个网络会处于巨大浪费之中。
![](https://pic3.zhimg.com/80/v2-9b6bfe2a307372452155134042833792_720w.jpg)
为了解决信道利用率低的问题，就需要使用连续ARQ协议和滑动窗口协议了。
![](https://pic4.zhimg.com/80/v2-718fbe1af085fe5dba147be654e3876b_720w.jpg)
如上图所示，发送方维持着一个发送窗口，它的意义是，发送窗口内的5个分组都可以连续地发送出去，而不需要等待对方的确认，这样信道利用率就高了。发送完一个分组后，窗口向前滑动，新的发送窗口就包含2到6这五个分组了，这就是滑动窗口。发送方每收到一个确认，就会把发送窗口向前滑动一个分组的位置。如上图，如果收到分组1的确认，发送窗口就滑动到6的位置了。
但接收方一般采用累积确认的方式，也就是说，接收方不必对收到的分组作逐个确认，而是在收到几个分组后，对按序到达的最后一个分组做确认就行，这就表示，到这个分组为止的所有分组都已确认。比如说，发送方发送完2到6之后，接收方发送6的确认，发送方就认为2到6都已经收到了，于是向前滑动5个分组，新的发送窗口变成7到11。
但这里有一个条件，接收方只对按序到达的最后一个分组作确认，如果接收方只收到2、3、6三个分组，4和5没有收到，那么接收方应该只发送3的确认。如果超时后还没有收到4和5的确认，会重新发送4、5、6，6也会被重发。

超时时间选择：
A向B发送了一个报文，但因为网络不好，B发送的确认报文A迟迟没有收到，A很着急，于是重发报文，但网络堵塞在那，A依然无法收到B的确认报文，反而因为A发了多次，导致网络更加堵塞了。
所以，有个关键问题，超时时间该如何确定呢？太短会引起很多不必要的重传，太长也不行，会让网络的空闲时间增大，影响效率。
TCP采用一种自适应算法。它记录一个报文段发出的时间，以及收到相应确认的时间，这两个时间之差不是报文段的往返时间RTT。
![](https://pic3.zhimg.com/80/v2-230752717c3ae3bb0066aa183b6eeba6_720w.jpg)
**新的加权平均往返时间RTTs = （1 - a）x 旧的RTTs + a x** **_新的RTT样本。_(其中0 < a < 1)**  
如果 a很小，趋近于0，说明新的RTT样本作用不大。  
如果 a 很大，趋近于1，则说明旧的RTTs对新的RTTs的影响很小。
当第一次取到RTT样本时，RTTs = RTT

现在通用的a的取值为1/8，即0.125。  
显然，新的RT0的值应该要略大于RTTs的值。  
**RTO = RTTs + 4 x RTTd（RTTd为RTT偏差的加权平均）**

第一次测量时，RTTd1 = RTT1 / 2
  
**新的RTTd = (1-B) x 旧的RTTd+B x |RTTs-_新的RTT样本_|** **。 (其中0< B<1)**  
B的建议取值为1/4，即0.25

当报文段重传时，就把超时重传时间RTO增大一些，典型的做法就是把新的重传时间设置为旧的重传时间的2倍。

流量控制：
网络的带宽有限，端处理数据速度有限，发送数据的速度应该要有限制，TCP使用滑动窗口来控制流量。
tcp的首部中，有个窗口字段，窗口字段告诉发送方，接收方此时还能最多接收多少数据。
另外，为了增加网络使用效率，tcp的数据字段也不宜过短，比如每次只发送一个字节的数据，这明显是不合适，因为tcp的首部至少有20字节，ip协议的首部也要20字节，整个tcp报文段不可能发这么多首部，而数据只有可怜的一点点。但如果报文长度太长了，也有问题，过长则需要分片，而分片了，效率就会降低。所以目前默认规定的最大报文长度MSS，为536字节。

拥塞控制：
假设端上处理能力非常强，有多少处理多少。那么发送端能无限制任意发送吗？明显是不行的，接收端处理能力强，不代表网络的带宽情况。如果网络拥堵的情况下，发送端发得过多，接收端依然收不到，还会导致大量的重发，效率相当低下。所以需要拥塞控制。
![](https://pic4.zhimg.com/80/v2-2036c3386d49ffcfa420cb024adce0b7_720w.jpg)
如何防止拥塞，其实用的是一种探测的思想，因为没有任何直接的可量化的参数能表明当前的网络拥塞程序，所以只好不停的探测，让网络处于一个较为高效的状态。
通常使用的方法叫慢开始。它的思路是这样的，当主机开始发送数据的时候，由小到大逐渐增大发送窗口，通常是在刚开始发送的时候，先把拥塞窗口设置为一个最大报文段MSS的数值，而在每收到一个对新的报文段的确认后，把拥塞窗口增加到多一个MSS的数据。用这样的方法逐步增大，可以让分组注入网络的速率更加合理。
拥塞窗口是发送端维持的一个状态变量，发送方让自己的发送窗口等于拥塞窗口。